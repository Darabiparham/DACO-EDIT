<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DACO</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700;800&display=swap" rel="stylesheet">
    <link href="https://cdn.fontcdn.ir/Font/Persian/Shabnam/Shabnam.css" rel="stylesheet">
    <style>
        :root {
            /* Light Theme Colors */
            --green-main: #1b3b14;
            --green-dark: #152e11;
            --orange-main: #ff6e41;
            --orange-dark: #c55633;
            --text-color-light: #2c3e50;
            --bg-color-light: #fff3e3;
            --panel-bg-light: rgba(255, 255, 255, 0.8);
            --border-color-light: #d4d9cc;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --icon-color-light: #2c3e50;
        }

        .night-mode {
            /* Dark Theme Colors */
            --green-main: #58731e;
            --green-dark: #6b8e23;
            --orange-main: #FF8C00;
            --orange-dark: #cc7000;
            --text-color-light: #f5f8f0;
            --bg-color-light: #2c3e50;
            --panel-bg-light: rgba(44, 62, 80, 0.9);
            --border-color-light: #3e5066;
            --shadow-color: rgba(255, 255, 255, 0.1);
            --icon-color-light: #f5f8f0;
        }

        /* General Styles & Layout */
        body {
            font-family: 'Vazirmatn', sans-serif;
            text-align: center;
            direction: rtl;
            background: var(--bg-color-light);
            color: var(--text-color-light);
            margin: 0;
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            transition: background 0.5s ease, color 0.5s ease;
        }

        .container {
            background: var(--panel-bg-light);
            padding: 32px;
            border-radius: 20px;
            box-shadow: 0 10px 30px var(--shadow-color);
            max-width: 1000px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 24px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color-light);
            transition: background 0.5s ease, border 0.5s ease;
        }

        .header {
            text-align: center;
            position: relative;
            margin-bottom: 20px;
        }
        
        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            gap: 16px;
        }

        #appTitle {
            font-size: 4rem;
            font-weight: 800;
            margin: 0;
            color: var(--text-color-light);
        }
        
        .subtitle {
            margin: 4px 0 0;
            color: var(--text-color-light);
            font-size: 1rem;
        }

        /* Top Controls */
        .top-controls {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 16px;
        }
        
        .top-right-controls {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        /* Theme & Language Toggles */
        .toggle-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.5rem;
            color: var(--icon-color-light);
            transition: color 0.3s ease;
        }

        .toggle-btn svg {
            width: 24px;
            height: 24px;
            stroke: var(--icon-color-light);
            fill: none;
            transition: stroke 0.3s ease;
        }

        .night-mode .sun-icon { display: none; }
        .night-mode .moon-icon { display: block; }
        .sun-icon { display: block; }
        .moon-icon { display: none; }

        .lang-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        
        .lang-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .lang-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color-light);
            transition: .4s;
            border-radius: 34px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 8px;
            color: var(--text-color-light);
            font-size: 1rem;
        }
        
        .lang-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: var(--orange-main);
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .lang-slider:before {
            transform: translateX(26px);
            background-color: var(--green-main);
        }

        /* Control Panels */
        .control-panel-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 16px;
            width: 100%;
        }

        .panel {
            background-color: var(--panel-bg-light);
            border-radius: 12px;
            padding: 16px;
            flex: 1;
            min-width: 250px;
            box-shadow: 0 4px 6px var(--shadow-color);
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-color-light);
            text-align: right;
            display: flex;
            flex-direction: column;
            gap: 12px;
            transition: background 0.5s ease, border 0.5s ease;
        }

        .panel-header {
            font-weight: 600;
            color: var(--text-color-light);
            border-bottom: 1px solid var(--border-color-light);
            padding-bottom: 8px;
            margin-bottom: 8px;
        }
        
        /* Input & Button Styles */
        input[type="file"] {
            display: none;
        }

        .custom-file-upload {
            border: 2px solid var(--border-color-light);
            background-color: var(--panel-bg-light);
            color: var(--text-color-light);
            padding: 12px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: fit-content;
            margin: 0 auto 24px auto;
        }

        .custom-file-upload:hover {
            border-color: var(--orange-main);
            box-shadow: 0 0 0 3px rgba(255, 140, 0, 0.2);
        }
        
        textarea {
            resize: none;
            height: 100px; /* Set a default height */
        }
        
        textarea,
        input[type="number"],
        select,
        button {
            padding: 12px 20px;
            border-radius: 12px;
            border: 2px solid var(--border-color-light);
            font-size: 1rem;
            transition: all 0.3s ease;
            outline: none;
            font-family: inherit;
            background-color: var(--panel-bg-light);
            color: var(--text-color-light);
        }

        textarea:focus, input:focus, select:focus {
            border-color: var(--orange-main);
            box-shadow: 0 0 0 3px rgba(255, 140, 0, 0.2);
        }
        
        select {
            flex: 1;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .add-font-btn {
            background: var(--orange-main);
            color: white;
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 2rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .add-font-btn:hover {
            background: var(--orange-dark);
        }

        button.primary {
            background: var(--green-main);
            color: white;
            cursor: pointer;
            border: none;
            font-weight: 700;
        }

        button.primary:hover {
            background: var(--green-dark);
        }
        
        button.secondary {
            background: var(--orange-main);
            color: white;
            cursor: pointer;
            border: none;
            font-weight: 700;
        }

        button.secondary:hover {
            background: var(--orange-dark);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-group label {
            min-width: 90px;
            text-align: right;
            font-size: 0.9rem;
            color: var(--text-color-light);
        }

        .slider-group input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            background: var(--border-color-light);
            height: 6px;
            border-radius: 3px;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--orange-main);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease;
        }

        .slider-value {
            font-weight: 600;
            min-width: 30px;
            text-align: left;
        }

        /* Black/White Toggle Switch */
        .color-toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
        }

        .color-toggle-label {
            font-weight: 600;
            color: var(--text-color-light);
            font-size: 0.9rem;
        }

        .color-toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .color-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .color-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color-light);
            transition: .4s;
            border-radius: 34px;
        }

        .color-toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .color-toggle-slider {
            background-color: var(--green-main);
        }

        input:checked + .color-toggle-slider:before {
            transform: translateX(26px);
            background-color: black;
        }
        
        .color-panel-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .font-add-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .backdrop-panel {
            border-top: 1px solid var(--border-color-light);
            padding-top: 12px;
            margin-top: 12px;
        }

        /* Canvas & Interaction */
        .canvas-container {
            position: relative;
            max-width: 100%;
            overflow: hidden;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            border: 1px solid var(--border-color-light);
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            touch-action: none;
        }
        
        #canvas.dragover {
            border: 2px dashed var(--orange-main);
            box-shadow: 0 0 10px rgba(255, 140, 0, 0.5);
        }
        
        .top-section-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            gap: 16px;
        }
        
        .top-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 16px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="top-section-container">
             <div class="header-top">
                <div class="top-controls">
                    <button class="toggle-btn" id="themeToggle">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </button>
                    <label class="lang-switch">
                        <input type="checkbox" id="langToggle">
                        <span class="lang-slider">
                            <span id="fa-label">فا</span>
                            <span id="en-label">En</span>
                        </span>
                    </label>
                </div>
                <div class="top-right-controls">
                     <button class="primary" id="downloadBtn">دانلود عکس</button>
                     <button class="secondary" id="downloadTextBtn">دانلود متن</button>
                     <button class="secondary" id="stickerBtn">افزودن استیکر</button>
                </div>
             </div>
             <div class="header">
                 <h2 id="appTitle">DACO</h2>
                 <p class="subtitle" id="appSubtitle">ساخته شده توسط @darabiparham</p>
             </div>
        </div>
       
        <label for="imageInput" class="custom-file-upload">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-image"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
            <span id="label-image">آپلود عکس</span>
        </label>
        <input type="file" id="imageInput" accept="image/*">

        <div class="control-panel-group">
            <div class="panel">
                <div class="panel-header" id="panel-text">متن</div>
                <textarea id="textInput" placeholder="متن خودت رو بنویس" rows="4"></textarea>
                
                <div class="font-add-group">
                    <label for="fontSelector" id="label-font">فونت</label>
                    <select id="fontSelector">
                        <option value="Vazirmatn" selected>Vazirmatn</option>
                        <option value="Shabnam">Shabnam</option>
                    </select>
                     <label for="fontInput" class="add-font-btn">+</label>
                     <input type="file" id="fontInput" accept=".ttf,.otf">
                </div>

                <div class="slider-group">
                    <label for="fontSizeSlider" id="label-font-size">سایز فونت</label>
                    <input type="range" id="fontSizeSlider" min="0" max="100" value="50">
                    <span id="fontSizeValue" class="slider-value">۵۰</span>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header" id="panel-color-opacity">رنگ و اپسیتی</div>
                
                <div class="color-toggle-container">
                    <span class="color-toggle-label" id="label-black-white-text">رنگ متن سیاه/سفید</span>
                    <label class="color-toggle-switch">
                        <input type="checkbox" id="blackWhiteToggle">
                        <span class="color-toggle-slider"></span>
                    </label>
                </div>
                
                <div class="color-panel-group">
                    <div class="slider-group">
                        <label for="redSlider" id="label-red">قرمز</label>
                        <input type="range" id="redSlider" min="0" max="255" value="0">
                        <span id="redValue" class="slider-value">۰</span>
                    </div>
                    <div class="slider-group">
                        <label for="greenSlider" id="label-green">سبز</label>
                        <input type="range" id="greenSlider" min="0" max="255" value="0">
                        <span id="greenValue" class="slider-value">۰</span>
                    </div>
                    <div class="slider-group">
                        <label for="blueSlider" id="label-blue">آبی</label>
                        <input type="range" id="blueSlider" min="0" max="255" value="0">
                        <span id="blueValue" class="slider-value">۰</span>
                    </div>
                </div>

                <div class="slider-group">
                    <label for="opacitySlider" id="label-opacity">اپسیتی متن</label>
                    <input type="range" id="opacitySlider" min="0" max="100" value="100">
                    <span id="opacityValue" class="slider-value">۱۰۰٪</span>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header" id="panel-effects">افکت‌ها</div>
                <div class="slider-group">
                    <label for="shadowSlider" id="label-shadow">سایه</label>
                    <input type="range" id="shadowSlider" min="0" max="20" value="0">
                    <span id="shadowValue" class="slider-value">۰</span>
                </div>
                <div class="slider-group">
                    <label for="strokeSlider" id="label-stroke">حاشیه</label>
                    <input type="range" id="strokeSlider" min="0" max="10" value="0">
                    <span id="strokeValue" class="slider-value">۰</span>
                </div>
                <div class="slider-group">
                    <label for="glowSlider" id="label-glow">درخشش</label>
                    <input type="range" id="glowSlider" min="0" max="20" value="0">
                    <span id="glowValue" class="slider-value">۰</span>
                </div>

                <div class="backdrop-panel">
                    <div class="panel-header" id="panel-backdrop">کادر پشت متن</div>
                    <div class="color-toggle-container">
                        <span class="color-toggle-label" id="label-black-white-backdrop">رنگ کادر سیاه/سفید</span>
                        <label class="color-toggle-switch">
                            <input type="checkbox" id="blackWhiteBackdropToggle">
                            <span class="color-toggle-slider"></span>
                        </label>
                    </div>
                    <div class="slider-group">
                        <label for="backdropOpacitySlider" id="label-backdrop-opacity">اپسیتی کادر</label>
                        <input type="range" id="backdropOpacitySlider" min="0" max="100" value="0">
                        <span id="backdropOpacityValue" class="slider-value">۰٪</span>
                    </div>
                    <div class="slider-group">
                        <label for="backdropRadiusSlider" id="label-backdrop-radius">گردی گوشه‌ها</label>
                        <input type="range" id="backdropRadiusSlider" min="0" max="100" value="0">
                        <span id="backdropRadiusValue" class="slider-value">۰</span>
                    </div>
                    <div class="slider-group">
                        <label for="backdropWidthSlider" id="label-backdrop-width">پهنای کادر</label>
                        <input type="range" id="backdropWidthSlider" min="0" max="100" value="0">
                        <span id="backdropWidthValue" class="slider-value">۰</span>
                    </div>
                     <div class="slider-group">
                        <label for="backdropHeightSlider" id="label-backdrop-height">ارتفاع کادر</label>
                        <input type="range" id="backdropHeightSlider" min="0" max="100" value="0">
                        <span id="backdropHeightValue" class="slider-value">۰</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script>
        const imageInput = document.getElementById('imageInput');
        const fontInput = document.getElementById('fontInput');
        const textInput = document.getElementById('textInput');
        const fontSelector = document.getElementById('fontSelector');
        const fontSizeSlider = document.getElementById('fontSizeSlider');
        const fontSizeValue = document.getElementById('fontSizeValue');
        const redSlider = document.getElementById('redSlider');
        const redValue = document.getElementById('redValue');
        const greenSlider = document.getElementById('greenSlider');
        const greenValue = document.getElementById('greenValue');
        const blueSlider = document.getElementById('blueSlider');
        const blueValue = document.getElementById('blueValue');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValue = document.getElementById('opacityValue');
        const shadowSlider = document.getElementById('shadowSlider');
        const shadowValue = document.getElementById('shadowValue');
        const strokeSlider = document.getElementById('strokeSlider');
        const strokeValue = document.getElementById('strokeValue');
        const glowSlider = document.getElementById('glowSlider');
        const glowValue = document.getElementById('glowValue');
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadTextBtn = document.getElementById('downloadTextBtn');
        const stickerBtn = document.getElementById('stickerBtn');
        const themeToggle = document.getElementById('themeToggle');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const backdropOpacitySlider = document.getElementById('backdropOpacitySlider');
        const backdropWidthSlider = document.getElementById('backdropWidthSlider');
        const backdropHeightSlider = document.getElementById('backdropHeightSlider');
        const backdropRadiusSlider = document.getElementById('backdropRadiusSlider');
        const backdropOpacityValue = document.getElementById('backdropOpacityValue');
        const backdropWidthValue = document.getElementById('backdropWidthValue');
        const backdropHeightValue = document.getElementById('backdropHeightValue');
        const backdropRadiusValue = document.getElementById('backdropRadiusValue');
        const blackWhiteToggle = document.getElementById('blackWhiteToggle');
        const blackWhiteBackdropToggle = document.getElementById('blackWhiteBackdropToggle');


        const translations = {
            fa: {
                appTitle: 'DACO',
                appSubtitle: 'ساخته شده توسط @darabiparham',
                labelImage: 'آپلود عکس',
                initialCanvasText: 'یک عکس بارگذاری کنید',
                panelText: 'متن',
                textInputPlaceholder: 'متن خودت رو بنویس',
                labelFont: 'فونت',
                labelFontSize: 'سایز فونت',
                panelColorOpacity: 'رنگ و اپسیتی',
                labelBlackWhiteText: 'رنگ متن سیاه/سفید',
                labelRed: 'قرمز',
                labelGreen: 'سبز',
                labelBlue: 'آبی',
                labelOpacity: 'اپسیتی متن',
                panelEffects: 'افکت‌ها',
                labelShadow: 'سایه',
                labelStroke: 'حاشیه',
                labelGlow: 'درخشش',
                panelBackdrop: 'کادر پشت متن',
                labelBlackWhiteBackdrop: 'رنگ کادر سیاه/سفید',
                labelBackdropOpacity: 'اپسیتی کادر',
                labelBackdropRadius: 'گردی گوشه‌ها',
                labelBackdropWidth: 'پهنای کادر',
                labelBackdropHeight: 'ارتفاع کادر',
                downloadBtn: 'دانلود عکس',
                downloadTextBtn: 'دانلود متن',
                stickerBtn: 'افزودن استیکر',
                alertImage: 'لطفاً ابتدا یک عکس بارگذاری کنید.',
                alertText: 'لطفاً متنی برای دانلود وارد کنید.',
                alertFont: 'شما می‌توانید حداکثر ۳ فونت سفارشی اضافه کنید.',
                alertFontSuccess: (fileName) => `فونت ${fileName} بارگذاری شد!`,
                alertFontError: (message) => `خطا در بارگذاری فونت: ${message}`,
                stickerSuccess: 'استیکر به کلیپ‌بورد کپی شد!'
            }
        };

        const currentLang = 'fa';
        const numToFa = (num) => String(num).replace(/\d/g, d => '۰۱۲۳۴۵۶۷۸۹'[d]);

        function setLanguage(lang) {
            const t = translations[lang];
            document.documentElement.lang = lang;
            document.body.style.direction = lang === 'fa' ? 'rtl' : 'ltr';

            document.getElementById('appTitle').textContent = t.appTitle;
            document.getElementById('appSubtitle').textContent = t.appSubtitle;
            document.getElementById('label-image').textContent = t.labelImage;
            document.getElementById('panel-text').textContent = t.panelText;
            document.getElementById('textInput').placeholder = t.textInputPlaceholder;
            document.getElementById('label-font').textContent = t.labelFont;
            document.getElementById('label-font-size').textContent = t.labelFontSize;
            document.getElementById('panel-color-opacity').textContent = t.panelColorOpacity;
            document.getElementById('label-black-white-text').textContent = t.labelBlackWhiteText;
            document.getElementById('label-red').textContent = t.labelRed;
            document.getElementById('label-green').textContent = t.labelGreen;
            document.getElementById('label-blue').textContent = t.labelBlue;
            document.getElementById('label-opacity').textContent = t.labelOpacity;
            document.getElementById('panel-effects').textContent = t.panelEffects;
            document.getElementById('label-shadow').textContent = t.labelShadow;
            document.getElementById('label-stroke').textContent = t.labelStroke;
            document.getElementById('label-glow').textContent = t.labelGlow;
            document.getElementById('panel-backdrop').textContent = t.panelBackdrop;
            document.getElementById('label-black-white-backdrop').textContent = t.labelBlackWhiteBackdrop;
            document.getElementById('label-backdrop-opacity').textContent = t.labelBackdropOpacity;
            document.getElementById('label-backdrop-radius').textContent = t.labelBackdropRadius;
            document.getElementById('label-backdrop-width').textContent = t.labelBackdropWidth;
            document.getElementById('label-backdrop-height').textContent = t.labelBackdropHeight;
            document.getElementById('downloadBtn').textContent = t.downloadBtn;
            document.getElementById('downloadTextBtn').textContent = t.downloadTextBtn;
            document.getElementById('stickerBtn').textContent = t.stickerBtn;
            
            updateSliderValues();
            drawCanvas(); 
        }

        let img = null;
        let fontSize = 50;
        let textColor = 'rgb(0,0,0)';
        let textOpacity = 1;
        let currentFont = 'Vazirmatn';
        let customFontsCount = 0;
        const MAX_CUSTOM_FONTS = 3;
        let shadowBlur = 0;
        let strokeWidth = 0;
        let glowBlur = 0;
        let isDragging = false;
        let isResizing = false;
        let selectedTextBox = { x: 0, y: 0, width: 200, height: 60 };
        let dragStartX = 0;
        let dragStartY = 0;
        let backdropColor = 'rgb(0,0,0)';
        let backdropOpacity = 0;
        let backdropRadius = 0; 
        let backdropWidthPercentage = 0;
        let backdropHeightPercentage = 0;
        let textMetrics = null;

        themeToggle.addEventListener('click', () => {
            document.body.classList.toggle('night-mode');
        });

        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            loadImage(file);
        });

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                img = new Image();
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    selectedTextBox.x = (canvas.width - selectedTextBox.width) / 2;
                    selectedTextBox.y = (canvas.height - selectedTextBox.height) / 2;
                    drawCanvas();
                };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        }

        fontInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file || customFontsCount >= MAX_CUSTOM_FONTS) {
                if (customFontsCount >= MAX_CUSTOM_FONTS) {
                    alert(translations.fa.alertFont);
                }
                return;
            }
            const fontName = `CustomFont_${Date.now()}`;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const font = new FontFace(fontName, ev.target.result);
                font.load().then(() => {
                    document.fonts.add(font);
                    const option = document.createElement('option');
                    option.value = fontName;
                    option.textContent = file.name.split('.')[0];
                    fontSelector.appendChild(option);
                    customFontsCount++;
                    currentFont = fontName;
                    fontSelector.value = fontName;
                    drawCanvas();
                    alert(translations.fa.alertFontSuccess(file.name));
                }).catch(error => {
                    alert(translations.fa.alertFontError(error.message));
                });
            };
            reader.readAsArrayBuffer(file);
        });

        textInput.addEventListener('input', drawCanvas);
        fontSelector.addEventListener('change', (e) => { currentFont = e.target.value; drawCanvas(); });
        fontSizeSlider.addEventListener('input', (e) => {
            fontSize = parseInt(e.target.value, 10);
            updateSliderValues();
            drawCanvas();
        });
        redSlider.addEventListener('input', updateTextColor);
        greenSlider.addEventListener('input', updateTextColor);
        blueSlider.addEventListener('input', updateTextColor);
        opacitySlider.addEventListener('input', (e) => {
            textOpacity = parseInt(e.target.value, 10) / 100;
            updateSliderValues();
            drawCanvas();
        });
        shadowSlider.addEventListener('input', (e) => {
            shadowBlur = parseInt(e.target.value, 10);
            updateSliderValues();
            drawCanvas();
        });
        strokeSlider.addEventListener('input', (e) => {
            strokeWidth = parseInt(e.target.value, 10);
            updateSliderValues();
            drawCanvas();
        });
        glowSlider.addEventListener('input', (e) => {
            glowBlur = parseInt(e.target.value, 10);
            updateSliderValues();
            drawCanvas();
        });
        
        backdropOpacitySlider.addEventListener('input', (e) => {
            backdropOpacity = parseInt(e.target.value, 10) / 100;
            updateSliderValues();
            drawCanvas();
        });
        backdropRadiusSlider.addEventListener('input', (e) => {
            backdropRadius = parseInt(e.target.value, 10);
            updateSliderValues();
            drawCanvas();
        });
        backdropWidthSlider.addEventListener('input', (e) => {
            backdropWidthPercentage = parseInt(e.target.value, 10);
            updateSliderValues();
            drawCanvas();
        });
        backdropHeightSlider.addEventListener('input', (e) => {
            backdropHeightPercentage = parseInt(e.target.value, 10);
            updateSliderValues();
            drawCanvas();
        });


        function updateSliderValues() {
            fontSizeValue.textContent = numToFa(fontSizeSlider.value);
            redValue.textContent = numToFa(redSlider.value);
            greenValue.textContent = numToFa(greenSlider.value);
            blueValue.textContent = numToFa(blueSlider.value);
            opacityValue.textContent = numToFa(opacitySlider.value) + '٪';
            shadowValue.textContent = numToFa(shadowSlider.value);
            strokeValue.textContent = numToFa(strokeSlider.value);
            glowValue.textContent = numToFa(glowSlider.value);
            backdropOpacityValue.textContent = numToFa(backdropOpacitySlider.value) + '٪';
            backdropRadiusValue.textContent = numToFa(backdropRadiusSlider.value);
            backdropWidthValue.textContent = numToFa(backdropWidthSlider.value);
            backdropHeightValue.textContent = numToFa(backdropHeightSlider.value);
        }

        blackWhiteToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                redSlider.value = 0;
                greenSlider.value = 0;
                blueSlider.value = 0;
            } else {
                redSlider.value = 255;
                greenSlider.value = 255;
                blueSlider.value = 255;
            }
            updateTextColor();
        });

        function updateTextColor() {
            const r = redSlider.value;
            const g = greenSlider.value;
            const b = blueSlider.value;
            textColor = `rgb(${r},${g},${b})`;
            updateSliderValues();
            drawCanvas();
        }

        blackWhiteBackdropToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                backdropColor = 'rgb(0,0,0)';
            } else {
                backdropColor = 'rgb(255,255,255)';
            }
            updateSliderValues(); 
            drawCanvas();
        });
        
        function drawCanvas() {
            let initialCanvas = false;
            if (!img) {
                initialCanvas = true;
                const canvasContainer = document.querySelector('.canvas-container');
                const desiredWidth = canvasContainer.offsetWidth * 0.8;
                canvas.width = desiredWidth;
                canvas.height = desiredWidth * 0.6;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (img) {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = "#e0e0e0";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            const textLines = textInput.value.split('\n');
            const hasText = textInput.value.trim() !== '';

            if (!hasText) {
                if (!img) {
                    ctx.fillStyle = "#888";
                    ctx.font = "20px Vazirmatn";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(translations.fa.initialCanvasText, canvas.width / 2, canvas.height / 2);
                }
                return;
            }

            let calculatedFontSize = fontSize;
            ctx.font = `${calculatedFontSize}px ${currentFont}`;
            let maxTextWidth = 0;
            textLines.forEach(line => {
                const metrics = ctx.measureText(line);
                if (metrics.width > maxTextWidth) {
                    maxTextWidth = metrics.width;
                }
            });

            // Calculate font size based on slider value and canvas width
            if (fontSize > 0) {
                 let tempFontSize = (fontSize / 100) * canvas.width;
                 ctx.font = `${tempFontSize}px ${currentFont}`;
                 let tempMetrics = 0;
                 textLines.forEach(line => {
                    const metrics = ctx.measureText(line);
                    if (metrics.width > tempMetrics) {
                        tempMetrics = metrics.width;
                    }
                 });
                 // If the text width is too big, scale it down proportionally
                 if (tempMetrics > canvas.width) {
                     const scaleFactor = (canvas.width / tempMetrics) * 0.95;
                     calculatedFontSize = tempFontSize * scaleFactor;
                 } else {
                    calculatedFontSize = tempFontSize;
                 }
            } else {
                calculatedFontSize = 0;
            }
            ctx.font = `${calculatedFontSize}px ${currentFont}`;
            maxTextWidth = 0;
            textLines.forEach(line => {
                const metrics = ctx.measureText(line);
                if (metrics.width > maxTextWidth) {
                    maxTextWidth = metrics.width;
                }
            });
            textMetrics = { width: maxTextWidth, height: calculatedFontSize * 1.5 };


            const backdropPaddingX = (backdropWidthPercentage / 100) * canvas.width;
            const backdropPaddingY = (backdropHeightPercentage / 100) * canvas.height;
            
            selectedTextBox.width = textMetrics.width + backdropPaddingX;
            selectedTextBox.height = (textMetrics.height * textLines.length) + backdropPaddingY;
            
            if (textMetrics.width > 0 && selectedTextBox.width < 50) selectedTextBox.width = 50;

            if (selectedTextBox.width > canvas.width) selectedTextBox.width = canvas.width;
            if (selectedTextBox.height > canvas.height) selectedTextBox.height = canvas.height;


            selectedTextBox.x = Math.max(0, Math.min(selectedTextBox.x, canvas.width - selectedTextBox.width));
            selectedTextBox.y = Math.max(0, Math.min(selectedTextBox.y, canvas.height - selectedTextBox.height));

            if (backdropOpacity > 0) {
                ctx.fillStyle = backdropColor;
                ctx.globalAlpha = backdropOpacity;
                const borderRadius = (backdropRadius / 100) * Math.min(selectedTextBox.width, selectedTextBox.height) / 2; 

                ctx.beginPath();
                ctx.moveTo(selectedTextBox.x + borderRadius, selectedTextBox.y);
                ctx.lineTo(selectedTextBox.x + selectedTextBox.width - borderRadius, selectedTextBox.y);
                ctx.arcTo(selectedTextBox.x + selectedTextBox.width, selectedTextBox.y, selectedTextBox.x + selectedTextBox.width, selectedTextBox.y + borderRadius, borderRadius);
                ctx.lineTo(selectedTextBox.x + selectedTextBox.width, selectedTextBox.y + selectedTextBox.height - borderRadius);
                ctx.arcTo(selectedTextBox.x + selectedTextBox.width, selectedTextBox.y + selectedTextBox.height, selectedTextBox.x + selectedTextBox.width - borderRadius, selectedTextBox.y + selectedTextBox.height, borderRadius);
                ctx.lineTo(selectedTextBox.x + borderRadius, selectedTextBox.y + selectedTextBox.height);
                ctx.arcTo(selectedTextBox.x, selectedTextBox.y + selectedTextBox.height, selectedTextBox.x, selectedTextBox.y + selectedTextBox.height - borderRadius, borderRadius);
                ctx.lineTo(selectedTextBox.x, selectedTextBox.y + borderRadius);
                ctx.arcTo(selectedTextBox.x, selectedTextBox.y, selectedTextBox.x + borderRadius, selectedTextBox.y, borderRadius);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            ctx.strokeStyle = '#556B2F';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            if (ctx.roundRect) {
                ctx.roundRect(selectedTextBox.x, selectedTextBox.y, selectedTextBox.width, selectedTextBox.height, 10);
            } else {
                ctx.rect(selectedTextBox.x, selectedTextBox.y, selectedTextBox.width, selectedTextBox.height);
            }
            ctx.stroke();
            ctx.setLineDash([]);


            ctx.font = `${calculatedFontSize}px ${currentFont}`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowColor = `rgb(0,0,0)`;
            ctx.shadowBlur = shadowBlur;
            ctx.strokeStyle = `rgb(0,0,0)`;
            ctx.lineWidth = strokeWidth * 2;
            ctx.lineJoin = 'round';
            ctx.miterLimit = 2;
            
            let lineY = selectedTextBox.y + (selectedTextBox.height / 2) - (((textLines.length - 1) / 2) * calculatedFontSize * 1.5);

            textLines.forEach(line => {
                if (strokeWidth > 0) {
                     ctx.strokeText(line, selectedTextBox.x + selectedTextBox.width / 2, lineY);
                }

                if (glowBlur > 0) {
                    ctx.shadowColor = textColor;
                    ctx.shadowBlur = glowBlur;
                    ctx.fillStyle = textColor;
                    ctx.globalAlpha = textOpacity;
                    ctx.fillText(line, selectedTextBox.x + selectedTextBox.width / 2, lineY);
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }

                ctx.fillStyle = textColor;
                ctx.globalAlpha = textOpacity;
                ctx.fillText(line, selectedTextBox.x + selectedTextBox.width / 2, lineY);
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
                
                lineY += calculatedFontSize * 1.5;
            });

            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.arc(selectedTextBox.x + selectedTextBox.width, selectedTextBox.y + selectedTextBox.height, 10, 0, 2 * Math.PI);
            ctx.fill();
        }

        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;
            if (isTouchDevice && e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }
            return {
                x: (clientX - rect.left) / (rect.width / canvas.width),
                y: (clientY - rect.top) / (rect.height / canvas.height)
            };
        }
        canvas.addEventListener(isTouchDevice ? 'touchstart' : 'mousedown', (e) => {
            e.preventDefault();
            const { x, y } = getCoords(e);
            const resizeHandleDistance = Math.hypot(x - (selectedTextBox.x + selectedTextBox.width), y - (selectedTextBox.y + selectedTextBox.height));
            if (resizeHandleDistance < 20) {
                isResizing = true;
                return;
            }
            if (x >= selectedTextBox.x && x <= selectedTextBox.x + selectedTextBox.width && y >= selectedTextBox.y && y <= selectedTextBox.y + selectedTextBox.height) {
                isDragging = true;
                dragStartX = x - selectedTextBox.x;
                dragStartY = y - selectedTextBox.y;
            }
        });
        canvas.addEventListener(isTouchDevice ? 'touchmove' : 'mousemove', (e) => {
            if (!isDragging && !isResizing) return;
            e.preventDefault();
            const { x, y } = getCoords(e);
            if (isDragging) {
                selectedTextBox.x = Math.max(0, Math.min(x - dragStartX, canvas.width - selectedTextBox.width));
                selectedTextBox.y = Math.max(0, Math.min(y - dragStartY, canvas.height - selectedTextBox.height));
            } else if (isResizing) {
                const newWidth = Math.max(100, x - selectedTextBox.x);
                const newHeight = Math.max(50, y - selectedTextBox.y);
                const newFontSize = newHeight / 1.5;
                
                const percentageOfCanvas = (newFontSize / canvas.width) * 100;
                fontSize = Math.round(percentageOfCanvas);
                if (fontSize > 100) fontSize = 100;
                fontSizeSlider.value = fontSize;
                
                updateSliderValues();
            }
            drawCanvas();
        });
        const handleEnd = () => {
            isDragging = false;
            isResizing = false;
        };
        canvas.addEventListener(isTouchDevice ? 'touchend' : 'mouseup', handleEnd);
        canvas.addEventListener(isTouchDevice ? 'touchcancel' : 'mouseout', handleEnd);

        function downloadImage() {
            const hasText = textInput.value.trim() !== '';
            if (!img && !hasText) {
                alert(translations.fa.alertImage);
                return;
            }
            
            const tempDownloadCanvas = document.createElement('canvas');
            const tempDownloadCtx = tempDownloadCanvas.getContext('2d');
            
            if (img) {
                tempDownloadCanvas.width = img.width;
                tempDownloadCanvas.height = img.height;
                tempDownloadCtx.drawImage(img, 0, 0);
            } else {
                if (!hasText) {
                    tempDownloadCanvas.width = canvas.width;
                    tempDownloadCanvas.height = canvas.height;
                    tempDownloadCtx.fillStyle = "#e0e0e0";
                    tempDownloadCtx.fillRect(0, 0, tempDownloadCanvas.width, tempDownloadCanvas.height);
                } else {
                    const textLines = textInput.value.split('\n');
                    const textMetrics = [];
                    let maxTextWidth = 0;
                    tempDownloadCtx.font = `100px ${currentFont}`;
                    textLines.forEach(line => {
                        const metrics = tempDownloadCtx.measureText(line);
                        textMetrics.push(metrics);
                        if (metrics.width > maxTextWidth) {
                            maxTextWidth = metrics.width;
                        }
                    });

                    const finalScale = 1;
                    const finalFontSize = (fontSize / 100) * canvas.width;
                    let longestLineScaled = 0;
                    tempDownloadCtx.font = `${finalFontSize}px ${currentFont}`;
                    textLines.forEach(line => {
                        const metrics = tempDownloadCtx.measureText(line);
                        if (metrics.width > longestLineScaled) {
                            longestLineScaled = metrics.width;
                        }
                    });

                    const backdropPaddingX = (backdropWidthPercentage / 100) * canvas.width;
                    const backdropPaddingY = (backdropHeightPercentage / 100) * canvas.height;
                    
                    tempDownloadCanvas.width = longestLineScaled + backdropPaddingX;
                    tempDownloadCanvas.height = (finalFontSize * 1.5 * textLines.length) + backdropPaddingY;
                    
                    tempDownloadCtx.fillStyle = "#e0e0e0";
                    tempDownloadCtx.fillRect(0, 0, tempDownloadCanvas.width, tempDownloadCanvas.height);
                }
            }
            
            if (hasText) {
                const textLines = textInput.value.split('\n');
                let maxTextWidth = 0;
                tempDownloadCtx.font = `${(fontSize / 100) * canvas.width}px ${currentFont}`;
                textLines.forEach(line => {
                    const metrics = tempDownloadCtx.measureText(line);
                    if (metrics.width > maxTextWidth) {
                        maxTextWidth = metrics.width;
                    }
                });

                const canvasTextHeight = (fontSize / 100) * canvas.width * 1.5 * textLines.length;
                const canvasBackdropWidth = maxTextWidth + (backdropWidthPercentage / 100) * canvas.width;
                const canvasBackdropHeight = canvasTextHeight + (backdropHeightPercentage / 100) * canvas.height;
                
                const finalScale = img ? img.width / canvas.width : 1;
                const finalBackdropWidth = canvasBackdropWidth * finalScale;
                const finalBackdropHeight = canvasBackdropHeight * finalScale;
                const finalX = selectedTextBox.x * finalScale;
                const finalY = selectedTextBox.y * finalScale;
                const finalFontSize = ((fontSize / 100) * canvas.width) * finalScale;
                const finalRadius = (backdropRadius / 100) * Math.min(finalBackdropWidth, finalBackdropHeight) / 2;

                if (backdropOpacity > 0) {
                    tempDownloadCtx.fillStyle = backdropColor;
                    tempDownloadCtx.globalAlpha = backdropOpacity;
                    
                    tempDownloadCtx.beginPath();
                    tempDownloadCtx.moveTo(finalX + finalRadius, finalY);
                    tempDownloadCtx.lineTo(finalX + finalBackdropWidth - finalRadius, finalY);
                    tempDownloadCtx.arcTo(finalX + finalBackdropWidth, finalY, finalX + finalBackdropWidth, finalY + finalRadius, finalRadius);
                    tempDownloadCtx.lineTo(finalX + finalBackdropWidth, finalY + finalBackdropHeight - finalRadius);
                    tempDownloadCtx.arcTo(finalX + finalBackdropWidth, finalY + finalBackdropHeight, finalX + finalBackdropWidth - finalRadius, finalY + finalBackdropHeight, finalRadius);
                    tempDownloadCtx.lineTo(finalX + finalRadius, finalY + finalBackdropHeight);
                    tempDownloadCtx.arcTo(finalX, finalY + finalBackdropHeight, finalX, finalY + finalBackdropHeight - finalRadius, finalRadius);
                    tempDownloadCtx.lineTo(finalX, finalY + finalRadius);
                    tempDownloadCtx.arcTo(finalX, finalY, finalX + finalRadius, finalY, finalRadius);
                    tempDownloadCtx.closePath();
                    tempDownloadCtx.fill();
                    tempDownloadCtx.globalAlpha = 1;
                }

                tempDownloadCtx.font = `${finalFontSize}px ${currentFont}`;
                tempDownloadCtx.globalAlpha = textOpacity;
                tempDownloadCtx.textAlign = "center";
                tempDownloadCtx.textBaseline = "middle";
                tempDownloadCtx.shadowColor = `rgb(0,0,0)`;
                tempDownloadCtx.shadowBlur = shadowBlur;
                tempDownloadCtx.strokeStyle = `rgb(0,0,0)`;
                tempDownloadCtx.lineWidth = strokeWidth * 2;
                tempDownloadCtx.lineJoin = 'round';

                let lineY = finalY + (finalBackdropHeight / 2) - (((textLines.length - 1) / 2) * finalFontSize * 1.5);
                textLines.forEach(line => {
                    if (strokeWidth > 0) {
                        tempDownloadCtx.strokeText(line, finalX + finalBackdropWidth / 2, lineY);
                    }
                    tempDownloadCtx.shadowColor = textColor;
                    tempDownloadCtx.shadowBlur = glowBlur;
                    tempDownloadCtx.fillStyle = textColor;
                    tempDownloadCtx.fillText(line, finalX + finalBackdropWidth / 2, lineY);
                    lineY += finalFontSize * 1.5;
                });

                tempDownloadCtx.globalAlpha = 1;
                tempDownloadCtx.shadowBlur = 0;
            }

            const link = document.createElement('a');
            link.download = 'edited_image.png';
            link.href = tempDownloadCanvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            drawCanvas();
        }
        
        downloadBtn.addEventListener('click', downloadImage);
        
        downloadTextBtn.addEventListener('click', () => {
            const hasText = textInput.value.trim() !== '';
            if (!hasText) {
                alert(translations.fa.alertText);
                return;
            }
            const textLines = textInput.value.split('\n');
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            const textMetrics = [];
            let maxTextWidth = 0;
            tempCtx.font = `100px ${currentFont}`;
            textLines.forEach(line => {
                const metrics = tempCtx.measureText(line);
                textMetrics.push(metrics);
                if (metrics.width > maxTextWidth) {
                    maxTextWidth = metrics.width;
                }
            });

            const finalFontSize = (fontSize / 100) * canvas.width;
            let longestLineScaled = 0;
            tempCtx.font = `${finalFontSize}px ${currentFont}`;
            textLines.forEach(line => {
                const metrics = tempCtx.measureText(line);
                if (metrics.width > longestLineScaled) {
                    longestLineScaled = metrics.width;
                }
            });

            const backdropPaddingX = (backdropWidthPercentage / 100) * canvas.width;
            const backdropPaddingY = (backdropHeightPercentage / 100) * canvas.height;
            
            tempCanvas.width = longestLineScaled + backdropPaddingX;
            tempCanvas.height = (finalFontSize * 1.5 * textLines.length) + backdropPaddingY;
            
            tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height); // Ensures transparent background

            if (backdropOpacity > 0) {
                tempCtx.fillStyle = backdropColor;
                tempCtx.globalAlpha = backdropOpacity;
                const borderRadius = (backdropRadius / 100) * Math.min(tempCanvas.width, tempCanvas.height) / 2;

                tempCtx.beginPath();
                tempCtx.moveTo(borderRadius, 0);
                tempCtx.lineTo(tempCanvas.width - borderRadius, 0);
                tempCtx.arcTo(tempCanvas.width, 0, tempCanvas.width, borderRadius, borderRadius);
                tempCtx.lineTo(tempCanvas.width, tempCanvas.height - borderRadius);
                tempCtx.arcTo(tempCanvas.width, tempCanvas.height, tempCanvas.width - borderRadius, tempCanvas.height, borderRadius);
                tempCtx.lineTo(borderRadius, tempCanvas.height);
                tempCtx.arcTo(0, tempCanvas.height, 0, tempCanvas.height - borderRadius, borderRadius);
                tempCtx.lineTo(0, borderRadius);
                tempCtx.arcTo(0, 0, borderRadius, 0, borderRadius);
                tempCtx.closePath();
                tempCtx.fill();
                tempCtx.globalAlpha = 1;
            }
            
            tempCtx.font = `${finalFontSize}px ${currentFont}`;
            tempCtx.fillStyle = textColor;
            tempCtx.globalAlpha = textOpacity;
            tempCtx.textAlign = "center";
            tempCtx.textBaseline = "middle";

            let lineY = (tempCanvas.height / 2) - (((textLines.length - 1) / 2) * finalFontSize * 1.5);
            textLines.forEach(line => {
                tempCtx.fillText(line, tempCanvas.width / 2, lineY);
                lineY += finalFontSize * 1.5;
            });
            
            tempCtx.globalAlpha = 1;

            const link = document.createElement('a');
            link.download = 'text_only.png';
            link.href = tempCanvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        stickerBtn.addEventListener('click', async () => {
            const hasText = textInput.value.trim() !== '';
            if (!hasText) {
                alert(translations.fa.alertText);
                return;
            }

            const textLines = textInput.value.split('\n');
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Calculate canvas size based on text and effects for transparency
            tempCtx.font = `100px ${currentFont}`;
            let maxTextWidth = 0;
            textLines.forEach(line => {
                const metrics = tempCtx.measureText(line);
                if (metrics.width > maxTextWidth) {
                    maxTextWidth = metrics.width;
                }
            });
            
            // Re-calculate font size based on max width to ensure it fits well
            const finalFontSize = (fontSize / 100) * (maxTextWidth * 1.2); 
            tempCtx.font = `${finalFontSize}px ${currentFont}`;
            
            const lineSpacing = finalFontSize * 0.3;
            const textHeight = textLines.length * finalFontSize + (textLines.length - 1) * lineSpacing;
            
            tempCanvas.width = maxTextWidth + (strokeWidth * 4) + (shadowBlur * 2) + (glowBlur * 2);
            tempCanvas.height = textHeight + (strokeWidth * 4) + (shadowBlur * 2) + (glowBlur * 2);

            tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

            tempCtx.font = `${finalFontSize}px ${currentFont}`;
            tempCtx.globalAlpha = textOpacity;
            tempCtx.textAlign = "center";
            tempCtx.textBaseline = "middle";
            tempCtx.shadowColor = `rgb(0,0,0)`;
            tempCtx.shadowBlur = shadowBlur;
            tempCtx.strokeStyle = `rgb(0,0,0)`;
            tempCtx.lineWidth = strokeWidth * 2;
            tempCtx.lineJoin = 'round';
            tempCtx.miterLimit = 2;

            let startY = (tempCanvas.height / 2) - (textHeight / 2) + (finalFontSize / 2);
            textLines.forEach(line => {
                if (strokeWidth > 0) {
                    tempCtx.strokeText(line, tempCanvas.width / 2, startY);
                }
                
                tempCtx.shadowColor = textColor;
                tempCtx.shadowBlur = glowBlur;
                tempCtx.fillStyle = textColor;
                tempCtx.fillText(line, tempCanvas.width / 2, startY);
                
                startY += finalFontSize + lineSpacing;
            });
            
            tempCtx.globalAlpha = 1;
            tempCtx.shadowBlur = 0;

            try {
                const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
                await navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]);
                alert(translations.fa.stickerSuccess);
            } catch (error) {
                console.error('Failed to copy image to clipboard:', error);
                alert('خطا در کپی استیکر به کلیپ‌بورد.');
            }
        });
        
        setLanguage('fa');
        drawCanvas();
    </script>
</body>
</html>